\documentclass[]{article}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{€}
\fi
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={Analyse numerique des equations differentielles},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}
 
/* start css.sty */
.cmr-5{font-size:50%;}
.cmr-7{font-size:70%;}
.cmmi-5{font-size:50%;font-style: italic;}
.cmmi-7{font-size:70%;font-style: italic;}
.cmmi-10{font-style: italic;}
.cmsy-5{font-size:50%;}
.cmsy-7{font-size:70%;}
.cmex-7{font-size:70%;}
.cmex-7x-x-71{font-size:49%;}
.msbm-7{font-size:70%;}
.cmtt-10{font-family: monospace;}
.cmti-10{ font-style: italic;}
.cmbx-10{ font-weight: bold;}
.cmr-17x-x-120{font-size:204%;}
.cmsl-10{font-style: oblique;}
.cmti-7x-x-71{font-size:49%; font-style: italic;}
.cmbxti-10{ font-weight: bold; font-style: italic;}
p.noindent { text-indent: 0em }
td p.noindent { text-indent: 0em; margin-top:0em; }
p.nopar { text-indent: 0em; }
p.indent{ text-indent: 1.5em }
@media print {div.crosslinks {visibility:hidden;}}
a img { border-top: 0; border-left: 0; border-right: 0; }
center { margin-top:1em; margin-bottom:1em; }
td center { margin-top:0em; margin-bottom:0em; }
.Canvas { position:relative; }
li p.indent { text-indent: 0em }
.enumerate1 {list-style-type:decimal;}
.enumerate2 {list-style-type:lower-alpha;}
.enumerate3 {list-style-type:lower-roman;}
.enumerate4 {list-style-type:upper-alpha;}
div.newtheorem { margin-bottom: 2em; margin-top: 2em;}
.obeylines-h,.obeylines-v {white-space: nowrap; }
div.obeylines-v p { margin-top:0; margin-bottom:0; }
.overline{ text-decoration:overline; }
.overline img{ border-top: 1px solid black; }
td.displaylines {text-align:center; white-space:nowrap;}
.centerline {text-align:center;}
.rightline {text-align:right;}
div.verbatim {font-family: monospace; white-space: nowrap; text-align:left; clear:both; }
.fbox {padding-left:3.0pt; padding-right:3.0pt; text-indent:0pt; border:solid black 0.4pt; }
div.fbox {display:table}
div.center div.fbox {text-align:center; clear:both; padding-left:3.0pt; padding-right:3.0pt; text-indent:0pt; border:solid black 0.4pt; }
div.minipage{width:100%;}
div.center, div.center div.center {text-align: center; margin-left:1em; margin-right:1em;}
div.center div {text-align: left;}
div.flushright, div.flushright div.flushright {text-align: right;}
div.flushright div {text-align: left;}
div.flushleft {text-align: left;}
.underline{ text-decoration:underline; }
.underline img{ border-bottom: 1px solid black; margin-bottom:1pt; }
.framebox-c, .framebox-l, .framebox-r { padding-left:3.0pt; padding-right:3.0pt; text-indent:0pt; border:solid black 0.4pt; }
.framebox-c {text-align:center;}
.framebox-l {text-align:left;}
.framebox-r {text-align:right;}
span.thank-mark{ vertical-align: super }
span.footnote-mark sup.textsuperscript, span.footnote-mark a sup.textsuperscript{ font-size:80%; }
div.tabular, div.center div.tabular {text-align: center; margin-top:0.5em; margin-bottom:0.5em; }
table.tabular td p{margin-top:0em;}
table.tabular {margin-left: auto; margin-right: auto;}
div.td00{ margin-left:0pt; margin-right:0pt; }
div.td01{ margin-left:0pt; margin-right:5pt; }
div.td10{ margin-left:5pt; margin-right:0pt; }
div.td11{ margin-left:5pt; margin-right:5pt; }
table[rules] {border-left:solid black 0.4pt; border-right:solid black 0.4pt; }
td.td00{ padding-left:0pt; padding-right:0pt; }
td.td01{ padding-left:0pt; padding-right:5pt; }
td.td10{ padding-left:5pt; padding-right:0pt; }
td.td11{ padding-left:5pt; padding-right:5pt; }
table[rules] {border-left:solid black 0.4pt; border-right:solid black 0.4pt; }
.hline hr, .cline hr{ height : 1px; margin:0px; }
.tabbing-right {text-align:right;}
span.TEX {letter-spacing: -0.125em; }
span.TEX span.E{ position:relative;top:0.5ex;left:-0.0417em;}
a span.TEX span.E {text-decoration: none; }
span.LATEX span.A{ position:relative; top:-0.5ex; left:-0.4em; font-size:85%;}
span.LATEX span.TEX{ position:relative; left: -0.4em; }
div.float img, div.float .caption {text-align:center;}
div.figure img, div.figure .caption {text-align:center;}
.marginpar {width:20%; float:right; text-align:left; margin-left:auto; margin-top:0.5em; font-size:85%; text-decoration:underline;}
.marginpar p{margin-top:0.4em; margin-bottom:0.4em;}
.equation td{text-align:center; vertical-align:middle; }
td.eq-no{ width:5%; }
table.equation { width:100%; } 
div.math-display, div.par-math-display{text-align:center;}
math .texttt { font-family: monospace; }
math .textit { font-style: italic; }
math .textsl { font-style: oblique; }
math .textsf { font-family: sans-serif; }
math .textbf { font-weight: bold; }
.partToc a, .partToc, .likepartToc a, .likepartToc {line-height: 200%; font-weight:bold; font-size:110%;}
.chapterToc a, .chapterToc, .likechapterToc a, .likechapterToc, .appendixToc a, .appendixToc {line-height: 200%; font-weight:bold;}
.index-item, .index-subitem, .index-subsubitem {display:block}
.caption td.id{font-weight: bold; white-space: nowrap; }
table.caption {text-align:center;}
h1.partHead{text-align: center}
p.bibitem { text-indent: -2em; margin-left: 2em; margin-top:0.6em; margin-bottom:0.6em; }
p.bibitem-p { text-indent: 0em; margin-left: 2em; margin-top:0.6em; margin-bottom:0.6em; }
.paragraphHead, .likeparagraphHead { margin-top:2em; font-weight: bold;}
.subparagraphHead, .likesubparagraphHead { font-weight: bold;}
.quote {margin-bottom:0.25em; margin-top:0.25em; margin-left:1em; margin-right:1em; text-align:\jmathustify;}
.verse{white-space:nowrap; margin-left:2em}
div.maketitle {text-align:center;}
h2.titleHead{text-align:center;}
div.maketitle{ margin-bottom: 2em; }
div.author, div.date {text-align:center;}
div.thanks{text-align:left; margin-left:10%; font-size:85%; font-style:italic; }
div.author{white-space: nowrap;}
.quotation {margin-bottom:0.25em; margin-top:0.25em; margin-left:1em; }
h1.partHead{text-align: center}
.sectionToc, .likesectionToc {margin-left:2em;}
.subsectionToc, .likesubsectionToc {margin-left:4em;}
.subsubsectionToc, .likesubsubsectionToc {margin-left:6em;}
.frenchb-nbsp{font-size:75%;}
.frenchb-thinspace{font-size:75%;}
.figure img.graphics {margin-left:10%;}
/* end css.sty */

\title{Analyse numerique des equations differentielles}
\author{}
\date{}

\begin{document}
\maketitle

\textbf{Warning: 
requires JavaScript to process the mathematics on this page.\\ If your
browser supports JavaScript, be sure it is enabled.}

\begin{center}\rule{3in}{0.4pt}\end{center}

{[}
{[}
{[}{]}
{[}

\subsubsection{16.6 Analyse numérique des équations différentielles}

\paragraph{16.6.1 Méthode d'Euler}

Soit f : J \times E \rightarrow~ E de classe \mathcal{C}^1 , soit t\_o dans J ,
y\_o dans E et \phi : J\_0 \rightarrow~ E la solution maximale
vérifiant la condition \phi(t\_o) = y\_o. J\_0 est
un intervalle contenu dans J et contenant t\_o, et dire que la
solution est maximale, c'est dire que \phi ne peut se prolonger en une
solution de l'équation différentielle sur un intervalle strictement plus
grand que J\_0. Notre but est de trouver une approximation de la
fonction \phi .

Pour cela soit h un nombre réel suffisamment petit et t dans
J\_0 tel que t + h appartienne encore à J\_0. Alors \phi(t
+ h) est peu différent de \phi(t) + h\phi'(t). Mais \phi'(t) = f(t,\phi(t)). Donc
\phi(t + h) est peu différent de \phi(t) + hf(t,\phi(t)) = y + f(t,y) si y =
\phi(t). Ceci nous amène à définir pour un nombre réel h donné

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  (i) une suite (t\_i)\_i\inℤ par t\_i =
  t\_o + ih
\item
  (ii) une suite (y\_i)\_i\inℤ par y\_i+1 =
  y\_i + hf(t\_i,y\_i) pour i ≥ 0,
  y\_i-1 = y\_i - hf(t\_i,y\_i) pour i \leq
  0
\item
  (iii) une fonction \phi\_h prenant aux points t\_i la
  valeur y\_i et affine sur chacun des intervalles
  {[}t\_i,t\_i+1{]}
\end{itemize}

Nous espérons bien entendu que la fonction \phi\_h ainsi définie
sera une approximation de \phi pour h petit. Nous allons montrer que c'est
effectivement le cas, tout au moins sur un segment {[}a,b{]} contenu
dans J\_0 et dans le cas simple où E = \mathbb{R}~ (bien que le résultat
reste valable si E est un espace vectoriel normé).

Remarquons tout d'abord que puisque f est de classe \mathcal{C}^1 et
que \phi'(t) = f(t,\phi(t)) , \phi' est dérivable et

\begin{align*} \phi'`(t)& =& \partial~f
\over \partial~t (t,\phi(t)) + \phi'(t) \partial~f \over
\partial~y (t,\phi(t)) \%& \\ & =& \partial~f
\over \partial~t (t,\phi(t)) + f(t,\phi(t)) \partial~f \over
\partial~y (t,\phi(t))\%& \\
\end{align*}

Soit \alpha~ \textgreater{} 0 et soit K = \(t,y) \in {[}a,b{]}
\times E∣\phi(t) - \alpha~ \leq y \leq \phi(t) +
\alpha~\.

K est un compact qui contient le graphe de \phi. La fonction
(t,y)\mapsto~ \partial~f \over \partial~t (t,y) +
f(t,y) \partial~f \over \partial~y (t,y) est continue sur ce compact,
donc bornée. Soit

M = sup\_(t,y)\inK~\textbar{} \partial~f
\over \partial~t (t,y) + f(t,y) \partial~f \over \partial~y
(t,y)\textbar{}

Alors on a pour tout t dans {[}a,b{]} \textbar{}\phi''(t)\textbar{}\leq M. La
formule de Taylor-Lagrange nous donne alors \phi(t + h) = \phi(t) + h\phi'(t) +
h^2 \over 2 \phi''(\xi), d'où

\left \textbar{} \phi(t + h) - \phi(t) \over
h - f(t,\phi(t))\right \textbar{}\leq M
\textbar{}h\textbar{} \over 2

D'autre part la fonction (t,y)\mapsto~ \partial~f
\over \partial~y (t,y) est continue sur K donc bornée. Soit A
= sup\_(t,y)\inK~\textbar{} \partial~f
\over \partial~y (t,y)\textbar{}. Alors on a si (t,y) \in K et
(t,y') \in K, f(t,y) - f(t,y') = (y - y') \partial~f \over \partial~y
(t,z) pour un certain z appartenant à {[}y,y'{]}, donc \textbar{}f(t,y)
- f(t,y')\textbar{}\leq A\textbar{}y - y'\textbar{} .

Définissons alors une suite (t\_i)\_i\in\mathbb{N}~ par t\_i
= t\_o + ih, une suite (y\_i)\_i\in\mathbb{N}~ par
y\_i+1 = y\_i + hf(t\_i,y\_i). Nous
allons mesurer l'erreur e\_i = \textbar{}y\_i -
\phi(t\_i)\textbar{}. Comme nous ne sommes malheureusement pas sûrs
que les couples (t\_i,y\_i) appartiennent à K nous
allons définir une fonction g : {[}a,b{]} \times \mathbb{R}~ \rightarrow~ \mathbb{R}~ par

g(x,y) = \left \ \cases
f(t,y) &si \phi(t) - \alpha~ \leq y \leq \phi(t) + \alpha~ \cr f(t,\phi(t) - \alpha~)&si
y \textless{} \phi(t) - \alpha~ \cr f(t,\phi(t) + \alpha~)&si y
\textgreater{} \phi(t) + \alpha~))  \right .

et une suite (z\_i)\_i\in\mathbb{N}~ par z\_i+1 =
z\_i + hg(t\_i,z\_i). Il est clair que
z\_i = y\_i tant que (t\_i,y\_i)
appartient à K. Posons \epsilon\_i = \textbar{}z\_i -
\phi(t\_i)\textbar{}. La fonction g est continue sur {[}a,b{]} \times \mathbb{R}~
et vérifie \textbar{}g(t,y) - g(t,y')\textbar{}\leq A\textbar{}y -
y'\textbar{} pour tout t \in {[}a,b{]} et tous y,y' \in \mathbb{R}~ d'après (2). On a
alors

\begin{align*} \epsilon\_i+1& =&
\textbar{}z\_i+1 - \phi(t\_i+1)\textbar{} =
\textbar{}z\_i + hg(t\_i,z\_i) - \phi(t\_i
+ h)\textbar{}\%& \\ & \leq&
\textbar{}z\_i - \phi(t\_i)\textbar{} +
\textbar{}h\textbar{}\textbar{}g(t\_i,z\_i) -
g(t\_i,\phi(t\_i))\textbar{} \%&
\\ & & +\textbar{}\phi(t\_i) +
hg(t\_i,\phi(t\_i)) - \phi(t\_i + h)\textbar{} \%&
\\ & \leq& \textbar{}z\_i -
\phi(t\_i)\textbar{} + A\textbar{}h\textbar{}\textbar{}z\_i
- \phi(t\_i)\textbar{} \%& \\ & &
+\textbar{}h\textbar{}\left \textbar{} \phi(t\_i +
h) - \phi(t\_i) \over h -
f(t\_i,\phi(t\_i))\right \textbar{} \%&
\\ \end{align*}

car g(t,\phi(t)) = f(t,\phi(t)). On obtient donc en utilisant (1)
\epsilon\_i+1 \leq (1 + A\textbar{}h\textbar{})\epsilon\_i + M
\textbar{}h\textbar{}^2 \over 2 . Comme
\epsilon\_o = e\_o = 0, on a donc par récurrence

\begin{align*} \epsilon\_i& \leq& M
\textbar{}h\textbar{}^2 \over 2 (1 + (1 +
A\textbar{}h\textbar{}) + \ldots + (1 +
A\textbar{}h\textbar{})^i-1)\%&
\\ & =& M
\textbar{}h\textbar{}^2 \over 2  (1 +
A\textbar{}h\textbar{})^i - 1 \over
\textbar{}h\textbar{}A \%& \\
\end{align*}

soit, puisque 1 + x \leq e^x,

\begin{align*} \epsilon\_i& \leq M&
\textbar{}h\textbar{} \over 2 
e^Ai\textbar{}h\textbar{}- 1 \over A
\leq\textbar{}h\textbar{} M \over 2A
(e^A\textbar{}t-ti\textbar{}- 1)\%&
\\ & \leq & \textbar{}h\textbar{} M
\over 2A (e^A(b-a) - 1) \%&
\\ \end{align*}

On voit donc que pour h assez petit, on a pour tout i tel que
t\_i appartienne à {[}a,b{]}, \epsilon\_i \leq \alpha~, donc
z\_i = y\_i, et donc \epsilon\_i = e\_i, avec
une erreur e\_i \leq\textbar{}h\textbar{} M \over
2A (e^A(b-a) - 1).

Soit maintenant x \in{]}t\_i,t\_i+1{[}. Considérons la
fonction affine g qui vérifie g(t\_i) = \phi(t\_i) et
g(t\_i+1) = \phi(t\_i+1). Soit h(t) = \phi(t) - g(t) - \mu
(t-t\_i)(t-t\_i+1) \over 2 où \mu est
choisi de telle sorte que h(x) = 0. Deux applications du théorème de
Rolle à la fonction h qui s'annule en t\_i, x et t\_i+1
montrent qu'il existe \xi tel que h''(\xi) = 0. Or h'`(\xi) = \phi''(\xi) - \mu
puisque g'' = 0. On a donc en écrivant que h(x) = 0,

\phi(x) - g(x) = \phi''(\xi) (x - t\_i)(x - t\_i+1)
\over 2

soit

\textbar{}\phi(x) - g(x)\textbar{}\leq M (t\_i+1 -
t\_i)^2 \over 8 = M h^2
\over 8

puisque l'on a vu que pour tout t dans {[}a,b{]},
\textbar{}\phi''(t)\textbar{}\leq M. Or g et \phi\_h sont affines sur
{[}t\_i,t\_i+1{]} et donc

\begin{align*} \textbar{}g(x) -
\phi\_h(x)\textbar{}& \leq&
max(\textbar{}g(t\_i~) -
\phi\_h(t\_i)\textbar{},\textbar{}g(t\_i+1) -
\phi\_h(t\_i+1)\textbar{})\%&
\\ & =&
max(e\_i,e\_i+1~)
\leq\textbar{}h\textbar{} M \over 2A
(e^A(b-a) - 1) \%& \\
\end{align*}

On en déduit donc que

\forall~~x \in {[}a,b{]}, \textbar{}\phi(x) -
\phi\_h(x)\textbar{}\leq\textbar{}h\textbar{} M \over
2A (e^A(b-a) - 1) + M h^2 \over
8

(en fait on n'a vu cette ma\jmathoration que sur {[}t\_o,b{]}, mais
il suffit de changer h en - h pour avoir le même résultat sur
{[}a,t\_o{]}, c'est pour cela que volontairement nous avons
laissé les valeurs absolues partout). Les fonctions \phi\_h
convergent donc uniformément vers \phi sur {[}a,b{]} quand h tend vers 0,
avec une ma\jmathoration du type

\forall~~x \in {[}a,b{]},\textbar{}\phi(x) -
\phi\_h(x)\textbar{}\leq B\textbar{}h\textbar{}

Dans la pratique il faut faire attention aux accumulations d'erreurs
d'arrondis. L'erreur sur le calcul de y\_n est de l'ordre de n\epsilon,
où \epsilon est la précision de calcul de l'ordinateur. On en déduit que
l'erreur sur le calcul de \phi\_h(x) est de l'ordre de grandeur de
 b-a \over h \epsilon. Soit une erreur totale du type Bh +
b-a \over h \epsilon. Une étude simple de cette fonction
montre que l'erreur totale est minimale pour des fonctions usuelles
quand h est de l'ordre de \sqrt\epsilon. On préférera
prendre une valeur de h un peu trop grande, plutôt que trop petite. Il
faut se méfier également du temps de calcul qui croit rapidement si l'on
prend des valeurs de h trop petites.

\paragraph{16.6.2 Méthode de Runge et Kutta}

La méthode est inspirée de la même idée que celle de la méthode d'Euler,
mais on améliore l'approximation faite. Dans la méthode d'Euler nous
prenions pour approximation de \phi(t + h) l'expression \phi(t) + h\phi'(t) =
\phi(t) + hf(t,\phi(t)). Ici on prendra comme approximation de \phi(t + h)
l'expression \phi(t) + hk(t,h) où k(t,h) est défini en posant

\begin{align*} k\_1(t,h)& =& f(t,\phi(t)),
\%& \\ k\_2(t,h)& =& f(t + h
\over 2 ,\phi(t) + h \over 2
k\_1(t,h)),\%& \\
k\_3(t,h)& =& f(t + h \over 2 ,\phi(t) + h
\over 2 k\_2(t,h)),\%&
\\ k\_4(t,h)& =& f(t + h,\phi(t) +
hk\_3(t,h)) \%& \\
\end{align*}

et enfin

k(t,h) = 1 \over 6 (k\_1(t,h) +
2k\_2(t,h) + 2k\_3(t,h) + k\_4(t,h)).

On définit donc notre suite y\_i par la relation de récurrence
y\_i+1 = y\_i + hk(i) où l'on a posé

\begin{align*} k\_1(i)& =&
f(t\_i,y\_i), \%& \\
k\_2(i)& =& f(t\_i + h \over 2
,y\_i + h \over 2 k\_1(i)), \%&
\\ k\_3(i)& =& f(t\_i
+ h \over 2 ,y\_i + h \over
2 k\_2(i)), \%& \\
k\_4(i)& =& f(t\_i + h,y\_i +
hk\_3(i)), \%& \\ k(i)& =& 1
\over 6 (k\_1(i) + 2k\_2(i) +
2k\_3(i) + k\_4(i))\%& \\
\end{align*}

pour i ≥ 0 , pour i \textless{} 0 on change h en - h.

On montre alors par un calcul pénible (à base de formule de Taylor) que

\left \textbar{} \phi(t+h)-\phi(t) \over h -
k(t,h)\right \textbar{}\leq M
\textbar{}h\textbar{}^4 \over 2 et la même
démonstration que dans la méthode d'Euler montre qu'il existe une
constante C telle que

\forall~~x \in {[}a,b{]}, \textbar{}\phi(x) -
\phi\_h(x)\textbar{}\leq C\textbar{}h\textbar{}^4 +
D\textbar{}h\textbar{}^2

Le terme en h^2 provient en fait de l'interpolation linéaire.
Aux points t\_i l'erreur est en fait en
C\textbar{}h\textbar{}^4. On obtient ainsi une convergence
beaucoup plus rapide que dans la méthode d'Euler. L'étude de
l'accumulation des erreurs montre que le meilleur h possible (pour les
points t\_i) est de l'ordre de
\root5\of\epsilon où \epsilon est la précision
de l'ordinateur. On pourra par exemple prendre un h de l'ordre de
10^-2 ou 10^-3.

\paragraph{16.6.3 Equations différentielles d'ordre supérieur}

Il suffit de rappeler qu'une équation différentielle d'ordre p du type
y^(p) = f(t,y,y',\ldots,y^(p-1)) se ramène à un
système différentiel

\left \\array
y\_1' & = y\_2 \cr
&\\ldots~\cr
y\_ p-1'& = y\_p \cr y\_p' & =
f(t,y\_1,y\_2,\ldots,y\_p) 
\right .

en posant y\_1 = y,y\_2 = y',\ldots,y\_p =
y^(p-1). On appliquera donc l'une des deux méthodes
précédentes à ce système.

{[}
{[}
{[}
{[}

\end{document}
